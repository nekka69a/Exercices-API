
Section 1 : Promesses et Gestion des Erreurs avec catch

[Explication dÃ©taillÃ©e]

ğŸ“˜ Une promesse est un objet qui reprÃ©sente la complÃ©tion ou l'Ã©chec d'une opÃ©ration asynchrone. Les promesses ont trois Ã©tats : pending, fulfilled, et rejected. Nous utilisons .then() pour manipuler le rÃ©sultat d'une promesse et .catch() pour gÃ©rer les erreurs.



âœï¸ Exemple d'utilisation d'une promesse pour une requÃªte HTTP simple :

fetch('https://api.example.com/data')

.then(response => response.json())

.then(data => console.log(data))

.catch(error => console.error('Error fetching data:', error));







Section 2 : Async/Await pour une Syntaxe Asynchrone Plus Claire

[Explication dÃ©taillÃ©e]

ğŸ“˜ Async et Await sont des extensions des promesses qui permettent d'Ã©crire des opÃ©rations asynchrones d'une maniÃ¨re plus lisible. Une fonction dÃ©clarÃ©e avec async retourne une promesse, et await peut Ãªtre utilisÃ© pour attendre la rÃ©solution de cette promesse.



âœï¸ Refactoring de l'exemple prÃ©cÃ©dent avec async/await :

async function fetchData() {

try {

const response = await fetch('https://api.example.com/data');

const data = await response.json();

console.log(data);

} catch (error) {

console.error('Error fetching data:', error);

}

}





Section 3 : Utilisation de fetch pour les RequÃªtes HTTP

[Explication dÃ©taillÃ©e]

ğŸ“˜ L'API Fetch permet de rÃ©aliser des requÃªtes HTTP asynchrones. Elle est promisifiÃ©e nativement, ce qui signifie qu'elle utilise les promesses pour gÃ©rer les rÃ©ponses.



âœï¸ Exemple d'utilisation de Fetch pour envoyer des donnÃ©es Ã  un serveur :

async function postData(url = '', data = {}) {

const response = await fetch(url, {

method: 'POST',

headers: {

'Content-Type': 'application/json'

},

body: JSON.stringify(data)

});

return response.json();

}